<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Write your site description here. It will be used as your sites meta description as well!">

    <title>TADP</title>

    <link rel="canonical" href="http://uqbar-project.github.io/scripts/clase_14/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">TADP</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
                <li>
                    <a href="/quienessomos/">Quienes Somos</a>
                </li>
                
                <li>
                    <a href="/administrativos/">Temas Administrativos</a>
                </li>
                
                <li>
                    <a href="/contenidos/">Contenidos</a>
                </li>
                
                <li>
                    <a href="/cursada/">Cursada</a>
                </li>
                
                <li>
                    <a href="/material/">Material</a>
                </li>
                
                <li>
                    <a href="/planificación/">Planificación</a>
                </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Page Header -->
<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="site-heading">
                    <h1>TADP</h1>
                    <hr class="small">
                    <span class="subheading">Script Clase 15 TADP 1C2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Main Content -->
<div class="container">
	<div class="row">
		<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
			<h1 id="el-compilador-y-usted">El compilador y usted</h1>

<p>Uno de los features más interesantes que ofrece un lenguaje es la capacidad de extenderlo. En mayor o menor
medida, siempre que escribo un programa “extiendo” de alguna manera lo que ya existe, pero algunas
tecnologías ofrecen además herramientas para, sin necesariamente cambiar su sintaxis, manipular la forma de
escribirlas.</p>

<p>Este tipo de herramientas permite eliminar gran cantidad de boilerplate y, a veces, crear una
manera completamente distinta de expresar la solución para un problema. Esto tiene un impacto muy grande en
la legibilidad y extensibilidad del código y permite crear desde mejoras menores para evitar repetición o
simplificar la lectura, hasta DSLs internos o sistemas de reescritura que aprovechan la metadata del código
para trabajar en mejores niveles de abstracción.</p>

<p>Vamos a contar algunos ejemplos de estás ideas implementadas en el lenguaje Scala. Cómo usarlas, qué pasa
abajo del capó y en qué situaciones podrían ser útiles. </p>

<h1 id="case-classes">Case Classes</h1>

<p>Una <em>Case Class</em> es una abstracción pensada para proveer una forma rápida y sintácticamente agradable para
crear estructuras inmutables similares a los <em>Tipos Algebraicos</em> de los lenguajes funcionales. Si bien son
un concepto interesante, lo más importante es entender que son solamente un “atajo”. Scala no hace nada
especial con las case classes, simplemente cada definición “case” es pasada por un proceso de reescritura
en el compilador: Por cada Case Class se define una clase común y corriente, pero se implementan
automáticamente algunos métodos bien conocidos coyo código es predecible o repetitivo.</p>

<p>Entonces, una <em>Case Class</em> es simplemente <em>una clase cualquiera</em> al que el compilador le agrega:
- Properties de sólo lectura para cada parámetro de clase
- Una forma sencilla de clonarla (método copy)
- Una conversión a String clara, basada en su nombre y sus parámetros de clase
- Métodos de comparación y hashing
- Un companion object que puede usarse para construir instancias y como patrón para matching
- Otros detalles (las case clases de aridad &gt;1 extienden Product) </p>

<p>Sólo con este poquito las diferencias que se producen en el cógido son enormes. Acá hay dos
implementaciones de la misma(*) clase, una usando <em>case classes</em> y una sin ellas.</p>

<h3 id="con-case-classes">Con Case Classes</h3>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Properties de sólo lectura
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>// Copy
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>// Conversión a String lindo
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>// Comparación / hashing
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>// Constructor sin new, parcialmente aplicable
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>// Unapply
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>// Etc...
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>case class Materia(nombre: String, ciclo: Int)(criterioDeAprobación: Alumno =&gt; Boolean) {
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>        def aprobados(curso: Curso) = curso filter criterioDeAprobación
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>}
</pre></div>
</div>
</div>

<h3 id="sin-case-classes">Sin Case Classes</h3>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>class Materia {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>        // Properties de sólo lectura
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>        private var _nombre: String = _
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        def nombre = _nombre
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        private var _ciclo: Int = _
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>        def ciclo = _ciclo
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        private var _criterioDeAprobación: Alumno =&gt; Boolean = _
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        private def criterioDeAprobación = _criterioDeAprobación
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        private def this(nombre: String, ciclo: Int, criterioDeAprovación: Alumno =&gt; Boolean) {
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>                this()
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>                _nombre = nombre
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>                _ciclo = ciclo
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>                _criterioDeAprobación = criterioDeAprobación
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>        }
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>        // Copy
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>        def copy(nombre: String = this.nombre, ciclo: Int = this.ciclo) = new Materia(nombre,ciclo,criterioDeAprobación)
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>        
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>        // Conversión a String lindo
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>        override def toString = s&quot;Materia($nombre, $ciclo)&quot;
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>        // Comparación / hashing
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>        override def equals(other: Any) = other match {
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>                case m: Materia =&gt; m.nombre == nombre &amp;&amp; m.ciclo == ciclo
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>                case _ =&gt; false
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>        }
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>        override def hashCode = ???
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>        def aprobados(curso: Curso) = curso filter criterioDeAprobación
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>}
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>object Materia {
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>        // Constructor sin new, parcialmente aplicable
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>        def apply(nombre: String, ciclo: Int) = { criterioDeAprobación: (Alumno =&gt; Boolean) =&gt;
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>                new Materia(nombre, ciclo, criterioDeAprobación)
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>        }
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>        // Unapply
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>        def unapply(materia: Materia): Option[(String, Int)] = ???
<span class="line-numbers"><a href="#n41" name="n41">41</a></span>}
</pre></div>
</div>
</div>

<h2 id="string-interpolators">String Interpolators</h2>

<p>Muchos lenguajes ofrecen la posibilidad de interpolar Strings para evitar el boilerplate y la confusión
producto de las cadenas larguisimas de concatenación necesarias para poder construir un string a partir de
multiples objetos.</p>

<p>La forma de hacer esto en scala es precediendo el string con una <em>s</em> y envolviendo las expresiones a
interpolar con ${…} (las expresiones que sólo consisten en una variable pueden prescindir de las llaves). </p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>val nombre = &quot;Técnicas Avanzadas de Programación&quot;
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>val ciclo = 3
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>val alumnos: List[Alumno] = ...
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>val sinInterpolación = &quot;La materia &quot; + nombre + &quot; del ciclo &quot; + ciclo + &quot; tiene &quot; + alumnos.size + &quot;alumnos&quot;
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>val conInterpolación = s&quot;La materia $nombre del ciclo $ciclo tiene ${alumnos.size} alumnos&quot;
</pre></div>
</div>
</div>

<p>La prueba de que esta forma de escritura es (al menos ligeramente) mejor que la concatenación directa está
en que la mayoría de la gente no nota a simple vista que al último string del ejemplo le falta un espacio ;)</p>

<p>Además de la “s” Scala ofrece otros interpoladores:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// f: Permite preceder las expresiones insertadas por un patron de formateo. Y es type safe!
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>val formateado = f&quot;El promedio en $nombre%s es ${alumnos.sum / alumnos.size}%2.2f&quot;
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>// raw: Trata a los caracteres especiales que modificarían el string como caracteres normales. 
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>val procesado   = s&quot;Estos\nSon\nSaltos\nDe\nLinea&quot;
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>val sinProcesar = raw&quot;Estos\nNo\nSon\nSaltos\nDe\nLinea&quot;
</pre></div>
</div>
</div>

<p>Sin embargo, el aspecto más interesante de la interpolación de strings en Scala es que <em>no son palabras
reservadas, sino mensajes</em>. Tanto <em>s</em> y <em>f</em> como <em>raw</em> son en realidad mensajes que el compilador envía a
una instancia de <em>StringContext</em> cuando ve el string literal. Esto permite que creemos nuestros propios
interpoladores extendiendo StringContext!</p>

<p>Digamos que tenemos una clase con la que representamos los mils y nos gustaría poder mostrar una lista de
mails mostrando sólo las primeras 4 letras y el dominio de cada uno (para evitar los crawlers). Una forma
posible para hacer esto es definir un interpolador que procese los parametros del tipo Email de forma
distinta a los demás:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>class Email(val id: String, val dominio: String) {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>        override def toString = s&quot;$id@$dominio&quot;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>        def toEncriptedString = s&quot;${id.take(4)}...@$dominio&quot;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>}
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>implicit class EmailsContext(val context: StringContext) {
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        def emails(arguments: Any*) = (&quot;&quot; /: context.parts.zip(arguments)) {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>                case (acum, (part, exp: Email)) =&gt; acum + part + exp.toEncriptedString
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>                case (acum, (part, exp))        =&gt; acum + part + exp
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        }
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>}
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>val nico = new Email(&quot;nscarcella&quot;, &quot;gmail.com&quot;)
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>val ernesto = new Email(&quot;bossi.ernestog&quot;, &quot;gmail.com&quot;)
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>val ivan = new Email(&quot;ivanlocolosredoooo1964&quot;, &quot;hotmail.com.es&quot;)
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>emails&quot;$nico, $ernesto, $ivan&quot; // Esto va a mostrar los mails encriptados
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>s&quot;$nico, $ernesto, $ivan&quot; // Esto va a mostrar los mails completos
</pre></div>
</div>
</div>

<p>Este es sólo un pequeño ejemplo de lo que se puede hacer con interpoladores. Noten que no hay ninguna
necesidad de que el método que se envía a un StringContext sea un String; esto quiere decir que podemos
usarlos para construir todo tipo de objetos a partir de Strings!</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>implicit class EmailContext(val context: StringContext) {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>        def mail(arguments: Any*): Email = {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>                val mergeado = context.s(arguments:_*)
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>                val extractor = &quot;(.*)@(.*)&quot;.r
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>                val extractor(id,dominio) = mergeado
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>                
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>                new Email(id,dominio)                        
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        }
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>mail&quot;un-id@un-dominio.com&quot; // retorna un Email
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>mail&quot;lalala&quot; // falla por no cumplir el patrón
</pre></div>
</div>
</div>

<p>Todo muy lindo pero cómo llegan esos métodos a StringContext? y que es esa palabra “implicit”? Bueno, eso
nos lleva al siguiente tema…</p>

<h2 id="implicits">Implicits</h2>

<p>Los implicits son una de las herramientas más novedosas y mágicas de Scala. Vienen en varios sabores, pero
lo que todos ellos tienen en común es que permiten poner cosas en un contexto para luego poder usarlas sin
una referencia explicita en el código (o sea, implicitamente :P).</p>

<h3 id="implicit-class">Implicit Class</h3>

<p>Una <em>Clase Implicita</em> es una forma declarativa y no-invasiva de extender una clase.</p>

<p>Digamos que buscamos agregarle comportamiento a un objeto <em>sin cambiar su implementación</em>. Una forma
conocida de hacer esto es anteponiendo otro objeto que sepa hacer el nuevo comportamiento y tenga una
referencia al objeto viejo para poder usar el comportamiento ya existente.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>class StringExtendido(unString: String) {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        // Este método es demasiado específico para querer ponerlo en String
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>        def esUnMail = unString.length &gt; 10 &amp;&amp; unString.contains(&quot;@&quot;) &amp;&amp; unString.endsWith(&quot;.com&quot;) 
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>new StringExtendido(&quot;foobar@gmail.com&quot;).esUnMail // Sí!
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>new StringExtendido(&quot;Hola Mundo!&quot;).esUnMail      // No!
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>&quot;Chau Mundo...&quot;.esUnMail                         // Esto no compila. No cambié la clase String.
</pre></div>
</div>
</div>

<p>La ventaja de esta aproximación es que puedo agregar tantos métodos cómo quiero sin preocuparme de que
colisionen diferentes implementaciones, ya que cada uno puede instanciar el “wrapper” de String que
prefiere; lo malo es que ensuciar el código para envolver al String.</p>

<p>Pero qué tal si pudiera explicarle al compilador lo que estoy tratando de hacer? Qué tal si pudiera pedirle
que, cuando vea que estoy mandandole a un String un mensaje que no entiende, que se fije a ver si está
definido en esta clase wrapper y, si está, que en vez de fallar me lo envuelva él solito?</p>

<p>Bueno, eso es exactamente lo que son las <em>Clases Implicitas</em>: Una clase común y corriente que, cuando están
en contexto, el compilador usa para wrapear objetos que no hubieran entendido algún mensaje.</p>

<p>Para definir una clase implicita, alcanza con hacerle recibir un único parámetro de clase del tipo que
quiero wrappear y anteponer la palabra “implicit” para que el compilador sepa que puede usarla:  </p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>implicit class StringExtendido(unString: String) {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        def esUnMail = unString.length &gt; 10 &amp;&amp; unString.contains(&quot;@&quot;) &amp;&amp; unString.endsWith(&quot;.com&quot;) 
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>}
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>&quot;foobar@gmail.com&quot;.esUnMail // Ahora esto funciona! El compilador wrappea el string sin que yo lo vea.
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>new StringExtendido(&quot;foobar@gmail.com&quot;).esUnMail // La linea de arriba se reescribe a esto. 
</pre></div>
</div>
</div>

<p>Es importante notar que el wrappeo automático sólo ocurre cuando mando un mensaje <em>que el objeto no
entiende</em>. Esto significa que las clases implicitas sirven para extender un tipo, pero no para redefinirle
implementaciones. Esto las convierte en una forma segura de extender una interfaz, sin preocuparse por
romper la implementación previa. Este es un buen momento para mirar el código que usamos para extender StringContext en
el tema anterior y asegurarse de entender que está pasando.</p>

<p>También hay que saber que el compilador no va a tratar de encadenar más de una aplicación de implicits por
expresión, así que hay que cuidar las firmas… </p>

<h2 id="implicit-methods-implicit-conversions">Implicit Methods (Implicit Conversions)</h2>

<p>Las conversiones implicitas son similares a las clases implicitas pero, en lugar de definir una nueva clase para extender
una referencia, se utiliza para convertir algo de un tipo a otro ya existente.</p>

<p>Digamos, por ejemplo, que tenemos un sistema con las siguientes interfaces::</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>class Punto(x: Int, y: Int)
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>object Mapa { def nombreDelLugar(lugar: Punto): String = ??? }
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>object Input { def puntoPresionado: (Int, Int) = ??? }
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span> 
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>// Pedirle al mapa el nombre del punto presionado 
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>val lugar = Input.puntoPresionado
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>Mapa nombreDelLugar Input.puntoPresionado // Sería lindo poder hacerlo así, pero una tupla no es un punto...
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>Mapa.nombreDelLugar(new Punto(lugar._1, lugar._2)) // Hay que hacer una conversión
</pre></div>
</div>
</div>

<p>Algo incomodo en este código es que, al pedir el punto presionado, recibo una Tupla2 pero lo que necesito es un Punto.
Semánticamente no es un problema, dado que tengo una forma concreta de convertir cualquier Tupla2 en un Punto. Podría
incluso evitar una posible repetición de esta lógica extrayendo esa conversión en una función:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>def tuplaAPunto(lugar: (Int,Int)) = new Punto(lugar._1, lugar._2)
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>Mapa.nombreDelLugar(tuplaAPunto(lugar)) // Ahora puedo usarlo así
</pre></div>
</div>
</div>

<p>Mejor? Sí. Pero si siempre que tengo una tupla y espero un punto tengo que aplicar esta función, sería lindo poder pedirle
al compilador que lo haga sin que yo lo tenga que escribir explicitamente; después de todo, mi función <em>tuplaAPunto</em> es
una transformación de Tuplas a Puntos.</p>

<p>Esto es exactamente para lo que las conversiones implicitas sirven. Puedo convertir una función que espera un único
parámetro en una conversión implicita anteponiendo la palabra implicit a su definición:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>implicit def tuplaAPunto(lugar: (Int,Int)) = new Punto(lugar._1, lugar._2)
</pre></div>
</div>
</div>

<p>De ahora en adelante, si esta función (que es del tipo Tupla2 =&gt; Punto) está en contexto, el compilador va a aplicarla
automáticamente cada vez que usemos una Tupla2 en un lugar donde se esperaba un Punto. Eso permite reescribir nuestro uso
así:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>Mapa.nombreDelLugar(Input.puntoPresionado)
</pre></div>
</div>
</div>

<p>Otro detalle interesante es que, por la forma en que Scala busca estos implicits, es posible, en lugar de importar la
función implicita en el contexto, definirla en el companion object de uno de los tipos en cuestión.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>object Punto {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        implicit def tuplaAPunto(lugar: (Int,Int)) = new Punto(lugar._1, lugar._2)
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>}
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>Mapa.nombreDelLugar(Input.puntoPresionado) // No necesito importar la función!
</pre></div>
</div>
</div>

<p>De esta manera estamos oficializando que un Punto puede ser obtenido a partir de una tupla en cualquier lugar.  </p>

<h3 id="implicit-parmeters">Implicit parámeters</h3>

<p>Los parámetros implícitos permiten establecer un valor por defecto para un parámetro, que puede ser configurado para cada
contexto. Si existe al momento de evaluar una función un valor implicito del tipo de uno de sus parámetros implicitos,
este valor se usa como parámetro automáticamente sin necesidad de escribirlo. Esto es especialmente útil cuando existen
una gran cantidad de llamadas a funciones que usan el mismo parámetro en un contexto:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>        class Persona { def persistir(db: BaseDeDatos) = ??? }
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>                
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>        class Familia(padre: Persona, madre: Persona, hijos: List[Persona], abuelos: List[Persona]) {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>                def persistir(db: BaseDeDatos) {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>                        padre.persistir(db)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>                        madre.persistir(db)
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>                        hijos.foreach(_.persistir(db))
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>                        abuelos.foreach(_.persistir(db))
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>                }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        }
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>        
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>        \\ ...
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>        
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>        val db: BaseDeDatos = ???
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>        unaFamilia.persistir(db)
</pre></div>
</div>
</div>

<p>En este ejemplo, la base de datos del método persistir puede declararse como un parámetro implicito anteponiendo la
palabra <em>implicit</em> al nombre del parámetro. Cabe aclarar que los parámetros implicitos deben ser los últimos parámetros
de la firma y deben estar en su propio grupo de aplicación. </p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>        class Persona { def persistir(implicit db: BaseDeDatos) = ??? }
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>                
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>        class Familia(padre: Persona, madre: Persona, hijos: List[Persona], abuelos: List[Persona]) {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>                def persistir(implicit db: BaseDeDatos) {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>                        padre.persistir
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>                        madre.persistir
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>                        hijos.foreach(_.persistir)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>                        abuelos.foreach(_.persistir)
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>                }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        }
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>        
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>        \\ ...
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>        
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>        implicit val db: BaseDeDatos = ???
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>        unaFamilia.persistir
</pre></div>
</div>
</div>

<p>Noten que, para poder evitar pasar el parámetro, es necesario que haya un <em>valor implicito</em> en el contexo. Los parámetros
implicitos son, a su vez, valores implicitos en el contexto del método.  </p>

<h3 id="type-clases">Type Clases</h3>

<p>Supongamos que tenemos un sistema que requiere poder persistir nuestros objetos de dominio utilizando multiples bases de
datos. Para mantener los ejemplos cortos, vamos a simplificar el problema suponiendo que solamente hace falta poder
guardar objetos (sin volver a leerlos o cambiarlos después).</p>

<p>Digamos que contamos con las siguientes interfaces para nuestras bases de datos:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>        object SQL { def run(query: String) = ??? }
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        object Redis { def guardar(clave: String, valor: String) = ??? }
</pre></div>
</div>
</div>

<h4 id="aproximacin-nave">Aproximación Naíve</h4>

<p>Una primera manera para integrar nuestro código a estas APIs es extendiendo la interfaz de nuestros objetos, agregando métodos para persistir en cada
tecnología.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// SQL --------------------------------------------------------------------------------------------
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>trait PersistibleConSQL {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        def tabla: String
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        def valores: List[String]
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>}
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>def persistirConSQL(obj: PersistibleConSQL) = {
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>        SQL run s&quot;INSERT INTO ${obj.tabla} VALUES ${obj.valores}&quot;
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>}
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>// Redis ------------------------------------------------------------------------------------------
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>trait PersistibleConRedis {
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>        def clave: String
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>        def valor: String
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>}
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>def persistirConRedis(obj: PersistibleConRedis) = {
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>        Redis guardar (obj.clave, obj.valor)
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>}
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>// Dominio ----------------------------------------------------------------------------------------
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>// Nuestra clase de dominio
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>case class C(f1: String, f2: String) extends PersistibleConRedis with PersistibleConSQL {
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>        def tabla = &quot;C&quot;
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>        def valores = List(f1, f2)
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>        def clave = &quot;C&quot;
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>        def valor = s&quot;{f1: $f1, f2: $f2}&quot;
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>}
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>// Uso --------------------------------------------------------------------------------------------
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>val c1 = new C(&quot;A&quot;, &quot;1&quot;)
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>val c2 = new C(&quot;B&quot;, &quot;2&quot;)
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>val c3 = new C(&quot;B&quot;, &quot;3&quot;)
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>persistirConSQL(c1)
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>persistirConRedis(c2)
<span class="line-numbers"><a href="#n41" name="n41">41</a></span>persistirConSQL(c3)
<span class="line-numbers"><a href="#n42" name="n42">42</a></span>persistirConRedis(c3)
</pre></div>
</div>
</div>

<p>Esta aproximación tiene varios problemas: Es muy invasiva y requiere que todos las clases que se desean persistir puedan ser modificadas, ensucia la
interfaz de dominio y, si bien no es el caso en este ejemplo, podrían haber conflictos entre las interfaces requeridas por cada base de datos.</p>

<h4 id="aproximacin-funcional">Aproximación Funcional</h4>

<p>Lenguajes como Haskell proponen una aproximación alternativa: <em>Type Classes</em>.</p>

<p>Una Type Class define un conjunto de operaciones que tienen que ser soportadas por un tipo para pertenecer a ella. Cualquier tipo T puede pertenecer a la
type class C si alguien provee las operaciones que ella exige.</p>

<p>Guiandonos por esta idea, podemos definir una Type Class “PersistibleConSQL” que especifique todo lo que un Tipo debe poder hacer para ser considerado
persistible usando SQL:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>trait PersistibleConSQL[T] {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        def tabla(obj: T): String
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>        def valores(obj: T): List[String]
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
</pre></div>
</div>
</div>

<p>Es importante notar que este trait no pretende ser <em>extendido</em> por los tipos persistibles con SQL, simplemente dice qué debe ser posible hacer con sus
instancias (en este caso, obtener una tabla y una lista de valores). Usando este trait, podemos reescribir nuestra función de persisitencia de la
siguiente forma:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>def persistirConSQL[T](obj: T)(persistible: PersistibleConSQL[T]) = {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        SQL run s&quot;INSERT INTO ${persistible.tabla(obj)} VALUES ${persistible.valores(obj)}&quot;
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>}
</pre></div>
</div>
</div>

<p>La función persistir ahora trabaja con dos parámetros: Uno de ellos es una instancia del tipo T, el cual queremos persistir. El otro parámetro debe ser
alguien que implemente las funciones tabla y valores sobre T. Este objeto es el que permite que T sea persistible con SQL, permitiendo desacoplar la idea
de persistencia de nuestro tipo de dominio.</p>

<p>Ahora podemos reescribir nuestro código sin ensuciarlo con lógica de persistencia. A cambio, debemos implementar un objeto aparte que lo vuelva
persistible:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>case class C(f1: String, f2: String)
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>object CSQL extends PersistibleConSQL[C] {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        def tabla(obj: C) = &quot;C&quot;
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        def valores(obj: C) = List(obj.f1, obj.f2)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>}
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>// uso
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>persistirConSQL(new C(&quot;foo&quot;, &quot;bar&quot;))(CSQL)
</pre></div>
</div>
</div>

<p>Podemos pensar que el trait PersistibleConSQL[T] es una Type Class y nuestro tipo de dominio C la implementa a travéz del objeto CSQL.</p>

<h4 id="mejorando-el-uso-con-implicits">Mejorando el uso con implicits</h4>

<p>El problema de esta solución es que ahora tengo que preocuparme por tener en contexto al objeto CSQL y pasarlo por parámetro cada vez que quiero usarlo.
Ahí es donde los parámetros implicitos hacen lo suyo! Si cambiamos nuestra función de persistencia para que el parametro que provee las funciones sea
implicito podemos dejar que el compilador lo escriba por nosotros.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>def persistirConSQL[T](obj: T)(implicit persistible: PersistibleConSQL[T]) = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>        SQL run s&quot;INSERT INTO ${persistible.tabla(obj)} VALUES ${persistible.valores(obj)}&quot;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>}
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>implicit object CSQL extends PersistibleConSQL[C] {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>        def tabla(obj: C) = &quot;C&quot;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        def valores(obj: C) = List(obj.f1, obj.f2)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>}
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>// uso
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>persistirConSQL(new C(&quot;foo&quot;, &quot;bar&quot;))
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
</pre></div>
</div>
</div>

<p>Esta forma de “extender” tipos es tan común y flexible que Scala provee una notación especial para definir funciones con type clases:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>def persistirConSQL[T](obj: T)(implicit persistible: PersistibleConSQL[T]) { ??? } // Esto mismo puede escribirse como está en la linea de abajo  
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>def persistirConSQL[T : PersistibleConSQL](obj: T) { ??? } // Acá se ve más claro que esperamos un tipo T que pertenece a la typeclass PersistibleConSQL 
</pre></div>
</div>
</div>

<p>Uh… Pero ahora ya no está el parámetro “persistible”! Cómo consigo la instancia? Scala provee una función llamada <em>implicitly</em> para estas situaciones:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>def persistirConSQL[T: PersistibleConSQL](obj: T) = {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        val persistible - implicitly[PersistibleConSQL[T]]
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>        SQL run s&quot;INSERT INTO ${persistible.tabla(obj)} VALUES ${persistible.valores(obj)}&quot;
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
</pre></div>
</div>
</div>

<h2 id="macros">Macros</h2>

<h3 id="qu-son">Qué son?</h3>

<p>Macros es una herramienta muy poderosa que permite definir reescrituras de AST (Abstract Syntax Tree) y está presente en
muchos lenguajes y tecnologías. A grandes razgos, la útilidad de las macros consiste en tomar una construcción sintáctica
válida y reemplazarla por otra en tiempo de compilación, permitiendo así que la sintaxis que normalmente construiría un
cierto programa construya otro totalmente diferente.</p>

<p>En Scala, la utilización de macros está definida en el paquete <code>scala.language.experimental.macros</code>, el cual debe ser
importado para poder trabajar.</p>

<p>Una macro de Scala se compone de dos partes: Una declaración y una implementación. Al momento de compilar, los usos de la
función declaración son procesados para reemplazarlos por el resultado de aplicar la función implementación. Definir la
declaración de una macro es muy similar a definir una función común pero, en lugar del cuerpo, se utiliza la palabra clave
<em>macro</em> seguida del nombre de la función implementación. </p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>  // declaración
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  def miMacro(parametro1: String, parametro2: Int) = macro miMacro_impl
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  // implementación
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  def miMacro_impl(c: Context)(parametro1: c.Expr[String], parametro2: c.Expr[Int]) = ???
</pre></div>
</div>
</div>

<h3 id="usos">Usos</h3>

<p>Veremos que hay varias maneras de colgarse del proceso de compilador, por lo que tenemos distintos tipos de macros propuestos por scala, solo que en este caso nos estaremos enfocando en uno de los tipos de macros. Otra consideración a tener en cuenta es que la interfaz que tenemos de macros como la de reflection en scala puede ir variando en el tiempo, ya que son aún implementaciones experimentales y no se ha llegado a un estado final de como sería la implementación definitiva.</p>

<p>Las macros han sido utilizados durante la versión 2.10 de Scala, tanto para aplicaciones de investigación como industriales, y la conclusión según [1], es que las macros han sido útiles para aplicaciones tales como:</p>

<ul>
  <li>Code Generation</li>
  <li>Implementation of DSLs</li>
  <li>Static checking among others</li>
</ul>

<h3 id="tipos">Tipos</h3>

<p>Existen 2 tipos de macros, las llamadas “de caja blanca” o <em>whitebox</em> y las “de caja negra” o <em>blackbox</em>. La diferencia
entre los dos enfoques es que las macros de caja negra se usan cuando puedo definir claramente una firma para la función
que quiero implementar usando macros, mientras que las de caja blanca se usan cuando no puedo definir dicha firma. Las
macros de caja blanca son más flexibles pero menos seguras, ya que no pueden tiparse y van a ser discontinuadas en
versiones futuras de Scala, por esa razón vamos a concentrarnos en las definiciones de caja negra.</p>

<p>Para elegir uno de estos dos enfoques es necesario importar el paquete correspondiente <code>scala.reflect.macros.whitebox</code>
para las de caja blanca y <code>import scala.reflect.macros.blackbox</code> para las de caja negra.</p>

<p>La clase Context que se usó en el código anterior está definida en estos paquetes.</p>

<p>Mirando el ejemplo, se puede ver que hay una relación entre el tipo de la declaración de la macro y su implementación que,
además de recibir un parámetro Context, espera también un parámetro por cada parámetro de la declaración que debe tener
el mismo nombre y un tipo de expresión que coincida. creado a partir del contexto. </p>

<h3 id="un-primer-ejemplo">Un primer ejemplo</h3>

<p>Empecemos por hacer una macros sencilla: la función identidad, que recibe un número y lo retorna:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>def id(n: Int): Int = macro id_impl
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>def id_impl(c: Context)(n: c.Expr[Int]): c.Expr[Int] = n
</pre></div>
</div>
</div>

<p>No fue tan difícil, no? Nuestra función id espera un Int y retorna un Int, por lo tanto, la macro con la que la
implementamos debe recibir (además del contexto) una expresión de tipo Int y retornar esa misma expresión. Es importante
notar que una expresión de tipo Int <em>no es</em> un Int, sino un fragmento de AST que, de ser evaluado, daría como resultado
un Int. Que sería el contexto en este caso y porque existe? Antes de eso vamos a explicar un poco algunos conceptos de lo que vimos recién. En el ejemplo que vimos el mismo se denominan def macros, y son métodos cuyas llamadas se expanden en tiempo de compilación, y con expansión se refiere en macros, a la transformación a código pero a nivel de compilación (no a al texto sintáctico ni al bytecode ejecutable, sino una representación intermedia de este) derivado del método al que se esta llamando con sus argumentos. El contexto se refiere al mismo en el cual se expone el código que será expandido y las rutinas que definimos que manipulan el código que deseemos transformar.</p>

<p>Otra parte del contexto de la macro es la funcion macroApplication, que nos permite proveer acceso al árbol de la expansión de la macro, y a pesar de que este arbol puede ser encontrado en argumentos de la implementación de la macro y en el método prefix, macroApplication nos permite dar un panorama más completo del contexto de la macro.</p>

<p>Veamos un ejemplo un poco más completo, por ejemplo implementemos un assert con macros…</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>  def assert(contidion: Boolean, msg: String): Unit = macro assert_impl
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  def assert_impl(c: Context)(contidion: c.Expr[Boolean], msg: c.Expr[String]) = {
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    import c.universe._
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    val q&quot;assert ($condition, $msg)&quot; = c.macroApplication
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    q&quot;if (!$condition) raise($msg)&quot;
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>  }
</pre></div>
</div>
</div>

<p>El ejemplo tiene un par de cosas nuevas, por un lado vemos un q seguido de un string con signos de $ refiriendose a variables, para empezar q es básicamente un método que nos permite, mediante un string interpolator al cual podemos referinos a parámetros o valores dentro de la implementación de la macro, crear y hacer pattern matching código que podemos generar o transformar. En este caso lo que se esta haciendo es pattern matchear todo el contexto que recibimos del assert a dos variables y luego genera un código condicional, en otras palabras si llamamos a </p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>assert(&quot;1 == 1&quot;, &quot;Uno no es igual a uno&quot;)
</pre></div>
</div>
</div>

<p>este código se reemplaza en tiempo de compilación cuando la macro se invoke y realice la expansión a </p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>if(! 1 == 1) raise(&quot;Uno no es igual a uno&quot;)
</pre></div>
</div>
</div>

<p>en la próxima sección veremos un poco más de lo que es este método q que permite que podamos crear estructuras mediante string interpolation.</p>

<h3 id="quasiquotes">Quasiquotes</h3>

<p>Implementar macros más complejas implica manipular el AST que conforma las expresiones. Esto es un trabajo muy pesado,
ya que requiere entender qué tipo de nodo se obtiene de cada posible expresión y como puede combinarse y deconstruirse
en base a otros.</p>

<p>Por suerte, las últimas versiones del framework de macros de Scala incluyen una herramienta muy poderosa para convertir
código a expresiones u obtener elementos a partir de un AST: <em>Los Quasiquotes</em>.</p>

<p>Quasiquotes son un tipo de StringContext que puede ser usado para aplicar y desaplicar valores desde/hacia un AST y
constituyen una interfaz relativamente accesible para manipular las expresiones.</p>

<p>El siguiente ejemplo usa quasiquotes para definir una macro que recibe una expresion por parámetro y loguea por consola
un aviso de que sentencia se va a ejecutar antes de evaluarla. </p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>def debug(code: =&gt; Unit): Unit = macro debug_impl
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>def debug_impl(c: Context)(code: c.Tree) = {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        import c.universe._
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>        val q&quot;..$sentences&quot; = code
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        val loggedSentences = (sentences :\ List[c.Tree]()){
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>                case (sentence, acum) =&gt;
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>                        val msg = &quot;Se va a ejecutar: &quot; + showCode(sentence)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>                        val printSentence = q&quot;println($msg)&quot;
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>                        printSentence :: sentence :: acum
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>        }
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>        q&quot;..$loggedSentences&quot;
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>}
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>//uso
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>val x = 10
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>debug {
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>  val x = 10         // Se va a ejecutar: val x = 10
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>  val y = 15         // Se va a ejecutar: val y = 15
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>  val z = x + y      // Se va a ejecutar: val z = x + y
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>}
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>
</pre></div>
</div>
</div>

<h3 id="validaciones-y-manejo-de-errores">Validaciones y manejo de errores</h3>

<p>El contexto de las macros permite realizar chequeos de tipos, validaciones sobre las expresiones e informar al compilador
de la necesidad de lanzar errores o warnings. Esto es un recurso excelente para validar construcciones estáticas en tiempo
de compilación.</p>

<p>El siguiente ejemplo retoma la idea de los mails con una macro que recibe un String y retorna un Email, pero falla si el
string no tiene el formato correcto. Este feedback puede verse en el mismo IDE, ya que se controla en tiempo de
compilación!</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>case class Email(id: String, domain: String)
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>def email(str: String): Email = macro email_impl
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>def email_impl(c: Context)(str: c.Expr[String]) = {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        import c.universe._
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        val emailFormat = &quot;&quot;&quot;(\w{4,})@([\w\.]+.com)&quot;&quot;&quot;.r
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>        str match {
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>                case Expr(Literal(Constant(emailFormat(id, domain)))) =&gt;        q&quot;&quot;&quot;Email($id,$domain)&quot;&quot;&quot;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>                case _ =&gt; c.abort(c.enclosingPosition, &quot;Formato inválido!!!&quot;)
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>        }
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>}
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>//uso
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>email(&quot;lalala@gmail.com&quot;) // Retorna Email(&quot;lalala&quot;, &quot;gmail.com&quot;)
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>email(&quot;lalalagmail.com&quot;) // Error de compilación! Formato inválido!
</pre></div>
</div>
</div>

<h2 id="poniendo-todo-junto">Poniendo todo junto</h2>

<p>Podemos dar un último paso combinando un poco de todo lo que vimos. En el siguiente ejemplo se muestra cómo puede
extenderse StringContext mediante implicits para crear mails que son validados en tiempo de compilación. Si bien hay que
poner un poco de esfuerzo extra para adecuar las firmas y los usos, este es un gran ejemplo de lo poderosas que pueden
ser estas herramientas cuando se usan juntas. </p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>case class Email(id: String, domain: String)
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>implicit class EmailStringContext(strCtx: StringContext) {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        def email(arguments: Any*): Email = macro email_impl
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>}
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>def email_impl(c: Context)(arguments: c.Expr[Any]*) = {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        import c.universe._
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        val emailFormat = &quot;&quot;&quot;(\w{4,})@([\w\.]+.com)&quot;&quot;&quot;.r
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>        
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>        c.prefix.tree match {
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>                  case Apply(_, List(Apply(_, rawParts))) =&gt;
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>                          val parts = rawParts map { case Literal(Constant(const: String)) =&gt; const }
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>                          val args = arguments map { case Literal(Constant(const: String)) =&gt; const }
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>                          val mail = (&quot;&quot; /: parts.zipAll(args, &quot;&quot;, &quot;&quot;)) {        case (acum, (part, arg)) =&gt; acum + part + arg        }
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>                
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>                          mail match {
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>                                  case emailFormat(id,domain) =&gt; q&quot;Email($id,$domain)&quot;
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>                                  case _ =&gt; c.abort(c.enclosingPosition, &quot;Invalid mail!!!&quot;)
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>                          }
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>                case _ =&gt; c.abort(c.enclosingPosition, &quot;Invalid mail!!!&quot;)
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>        }
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>}
</pre></div>
</div>
</div>

<p>Noten que no podemos pasarle a la macro el parámetro extra que el StringContext necesita, así que tenemos que obtenerlo
en base al contexto. </p>

<h2 id="referencias">Referencias</h2>
<ul>
  <li><a href="http://docs.scala-lang.org/tutorials/tour/case-classes.html">http://docs.scala-lang.org/tutorials/tour/case-classes.html</a></li>
  <li><a href="http://docs.scala-lang.org/overviews/core/string-interpolation.html">http://docs.scala-lang.org/overviews/core/string-interpolation.html</a></li>
  <li><a href="http://docs.scala-lang.org/overviews/core/implicit-classes.html">http://docs.scala-lang.org/overviews/core/implicit-classes.html</a></li>
  <li><a href="http://docs.scala-lang.org/tutorials/tour/implicit-conversions">http://docs.scala-lang.org/tutorials/tour/implicit-conversions</a></li>
  <li><a href="http://docs.scala-lang.org/tutorials/tour/implicit-parameters.html">http://docs.scala-lang.org/tutorials/tour/implicit-parameters.html</a></li>
  <li><a href="http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html">http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html</a></li>
  <li><a href="http://docs.scala-lang.org/overviews/macros/overview.html">http://docs.scala-lang.org/overviews/macros/overview.html</a></li>
  <li><a href="http://docs.scala-lang.org/overviews/macros/quasiquotes.html">http://docs.scala-lang.org/overviews/macros/quasiquotes.html</a></li>
</ul>

		</div>
	</div>
</div>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="https://github.com/uqbar-paco">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; TADP 2016</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


</body>

</html>
